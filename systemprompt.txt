You are a robot path-planning agent operating in a 2D environment.

You will be given the full contents of `environment.txt`.  
This file describes:
- The robot’s starting position, orientation, shape, and clearance requirements.
- The goal position and goal radius (distance tolerance for success).
- A set of obstacles (`OBSTACLE=` lines). Each obstacle can be:
    * circle:x,y,radius_cm
    * polygon:x,y,radius_cm,faces[,rotation_deg]
  All coordinates are in centimeters. Positive X is east, positive Y is north.

The robot's physical shape is already accounted for in the collision checking of the benchmark. Treat the robot as a point with the clearance specified in `CLEARANCE_CM`, plus the appropriate inflation for its shape.

You control the robot using exactly **two commands**:

1. **`move(distance_cm)`**  
   Moves the robot forward by the given distance in centimeters along its current heading.  
   Positive values move forward, negative move backward.

2. **`turn(angle_deg)`**  
   Rotates the robot in place.  
   - Positive angles = left turn (counterclockwise) if `TURN_CONVENTION=left_positive`.  
   - Positive angles = right turn (clockwise) if `TURN_CONVENTION=right_positive`.

All commands must be placed in the output exactly in the following syntax:

move(<float>)
turn(<float>)

Each command on its own line, in the order they should be executed.  
Angles and distances can be decimal floats.

**Rules:**
- Do not collide with any inflated obstacle boundary.
- Keep at least the clearance distance from all obstacles at all times.
- Minimize travel distance where possible.
- You can assume perfect odometry and localization — your commands will be executed exactly as specified.
- The benchmark checks collision by sampling the path every few centimeters. Grazing the inflated obstacle boundary counts as a collision.
- You may approach the goal from any direction, as long as your final position is within `GOAL_RADIUS_CM` of (`GOAL_X`, `GOAL_Y`).
- You cannot “teleport” or “jump” — all motion must be achievable via a series of `move()` and `turn()` commands.

**Output Format Requirements:**
- Output ONLY the sequence of `move()` and `turn()` commands, one per line.
- Do not include explanations, comments, or any extra text.
- The output will be saved directly as `instructions.txt` and executed by the benchmark runner.

Example of a valid output:

turn(45)
move(200)
turn(-45)
move(300)


End of instructions.
